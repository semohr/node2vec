import cppsnap
import networkx as nx
import numpy as np
import psutil
from gensim.models import Word2Vec
from scipy import sparse

from node2vec.helpers import check_adj_matrix
from node2vec.helpers import check_edge_list
from node2vec.helpers import is_symmetric
from node2vec.helpers import wv_to_numpy_array

USABLE_CPUS = psutil.cpu_count()


class Node2Vec:
    """
    The node2vec model.

    Attributes
    ----------
    walks: ndarray[np.int32]
        The biased random walks generated when running the simulate_walks method.
    embeddings: ndarray[np.int32]
        The node embeddings generated by the Skip-Gram model from the biased random
        walks.
    word2vec_model: gensim.models.Word2Vec
        The Gensim Word2Vec model used to generate the vector embeddings.

    Parameters
    ----------
    src_nodes: ndarray[np.int32]
        Identifiers of the source nodes for each edge.
        The length of the array is equal to the number of edges in the graph.
    dest_nodes: ndarray[np.int32]
        Identifiers of the destination nodes for each edge.
        The length of the array is equal to the number of edges in the graph.
    edge_weights: ndarray[np.double] (default: None)
        Weights of the edges. If the graph is unweighted leave empty or pass None.
    graph_is_directed: bool (default: False)
        Indicates whether the graph is directed. Default behaviour is to consider
        that the graph is undirected.

    Reference
    ---------
    Grover, A., & Leskovec, J. (2016, August).
    node2vec: Scalable feature learning for networks.
    In Proceedings of the 22nd ACM SIGKDD international conference on Knowledge
    discovery and data mining (pp. 855-864). ACM.
    """

    def __init__(
        self, src_nodes, dest_nodes, edge_weights=None, graph_is_directed: bool = False,
    ):
        check_edge_list(src_nodes, dest_nodes, edge_weights)

        self._src_nodes = src_nodes.astype(np.int32, copy=False)
        self._dest_nodes = dest_nodes.astype(np.int32, copy=False)

        if edge_weights is None:
            edge_weights = np.ones(len(src_nodes), dtype=np.double)

        self._edge_weights = edge_weights.astype(np.double, copy=False)
        self._graph_is_directed = graph_is_directed

        self._walks = None
        self._word2vec_model = None
        self._embeddings = None

    @staticmethod
    def from_nx_graph(nx_graph):
        """
        Instantiate a node2vec model from a NetworkX graph.

        Note: when dealing with large graphs prefer to use the class constructor for
        more efficiency.

        Parameters
        ----------
        nx_graph: networkx.Graph
            The graph (directed or not) that will be used by node2vec.
        """

        graph_is_directed = nx_graph.is_directed()
        if graph_is_directed:
            nx_graph = nx_graph.to_undirected(as_view=True)

        src_nodes = []
        dest_nodes = []

        if nx.is_weighted(nx_graph):
            edge_weights = []

            for src, dest, attr in nx.to_edgelist(nx_graph):
                src_nodes.append(src)
                dest_nodes.append(dest)
                edge_weights.append(attr["weight"])
        else:
            edge_weights = None

            for src, dest, attr in nx.to_edgelist(nx_graph):
                src_nodes.append(src)
                dest_nodes.append(dest)

        if edge_weights is not None:
            edge_weights = np.array(edge_weights, dtype=np.double)

        return Node2Vec(
            src_nodes=np.array(src_nodes, dtype=np.int32),
            dest_nodes=np.array(dest_nodes, dtype=np.int32),
            edge_weights=edge_weights,
            graph_is_directed=graph_is_directed,
        )

    @staticmethod
    def from_adj_matrix(adj_matrix):
        """
        Instantiate a node2vec model from an adjacency matrix inputted as a dense
        numpy array. The adjacency matrix can correspond to a directed or an undirected
        graph.

        Note: when dealing with large graphs prefer to use the class constructor for
        more efficiency.

        Parameters
        ----------
        adj_matrix: ndarray[np.double] of size n_nodes * n_nodes
            The adjacency matrix of the graph that will be used by node2vec.
        """

        check_adj_matrix(adj_matrix)

        graph_is_directed = not is_symmetric(adj_matrix)

        if not graph_is_directed:
            adj_matrix = np.triu(adj_matrix)

        sparse_matrix = sparse.coo_matrix(adj_matrix)

        return Node2Vec(
            src_nodes=sparse_matrix.row,
            dest_nodes=sparse_matrix.col,
            edge_weights=sparse_matrix.data,
            graph_is_directed=graph_is_directed,
        )

    def simulate_walks(
        self,
        walk_length: int = 80,
        n_walks: int = 10,
        p: float = 1.0,
        q: float = 1.0,
        workers: int = USABLE_CPUS,
        verbose: bool = True,
        rand_seed: int = None,
    ):
        """
        Repeatedly simulate random walks from each node.

        Parameters
        ----------
        walk_length: int (default: 80)
            Length of walk per source node.
        n_walks: int (default: 10)
            Number of walks per source node.
        p: int (default: 1)
            Return hyperparameter.
        q: int (default: 1)
            Inout hyperparameter.
        workers: (default: USABLE_CPUS)
            Number of worker threads used.
        verbose: bool (default: True)
            Verbosity of the output.
        rand_seed: int (default: None)
            Seed for the random number generator. Use a fixed random seed to produce
            deterministic runs. To ensure fully deterministic runs you also need to
            set workers = 1.
        """

        if rand_seed is None:
            rand_seed = 0

        self._walks = cppsnap.simulate_biased_random_walks(
            src_nodes=self._src_nodes,
            dest_nodes=self._dest_nodes,
            edge_weights=self._edge_weights,
            graph_is_directed=self._graph_is_directed,
            walk_length=walk_length,
            n_walks=n_walks,
            p=p,
            q=q,
            workers=workers,
            verbose=verbose,
            rand_seed=rand_seed,
        )

    def learn_embeddings(
        self,
        dimensions: int = 128,
        context_size: int = 10,
        epochs: int = 1,
        workers: int = USABLE_CPUS,
        verbose: bool = True,
        rand_seed: int = None,
    ):
        """
        Learn embeddings using the Skip-Gram model.

        dimensions: int (default: 128)
            Number of dimensions of the generated vector embeddings.
        context_size: int (default: 10)
            Context size (window size) in Word2Vec.
        epochs: int (default: 1)
            Number of epochs in stochastic gradient descent.
        workers: (default: USABLE_CPUS)
            Number of worker threads used.
        verbose: bool (default: True)
            Verbosity of the output.
        rand_seed: int (default: True)
            Seed for the random number generator. Use a fixed random seed to produce
            deterministic runs. To ensure fully deterministic runs you also need to
            set workers = 1. Reproducibility between Python interpreter launches
            also requires use of the PYTHONHASHSEED environment variable to control
            hash randomization.
        """

        if self._walks is None:
            raise RuntimeError(
                "You must run simulate_walks before running learn_embeddings."
            )

        if verbose:
            print("Learning embeddings using the Skip-Gram model...")

        walks = self._walks.astype(str).tolist()
        word2vec_args = {
            "sentences": walks,
            "vector_size": dimensions,
            "window": context_size,
            "min_count": 0,
            "sg": 1,  # use skip-gram
            "workers": workers,
            "epochs": epochs,
        }

        if rand_seed is not None:
            word2vec_args["seed"] = rand_seed

        self._word2vec_model = Word2Vec(**word2vec_args)
        self._embeddings = wv_to_numpy_array(self._word2vec_model.wv)

        if verbose:
            print("Learning embeddings: done!")

    @property
    def walks(self):
        if self._walks is None:
            raise RuntimeError(
                "You must run simulate_walks before accessing the generated walks."
            )

        return self._walks

    @property
    def embeddings(self):
        if self._embeddings is None:
            raise RuntimeError(
                "You must run learn_embeddings before accessing the generated embeddings."  # noqa: E501
            )

        return self._embeddings

    @property
    def word2vec_model(self):
        if self._word2vec_model is None:
            raise RuntimeError(
                "You must run learn_embeddings before accessing the word2vec model."
            )

        return self._word2vec_model
